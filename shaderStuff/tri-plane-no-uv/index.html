<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Tri-Plane Shader</title>
	<script src="https://preview.babylonjs.com/babylon.js"></script>
	
	<style>
		html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
	</style>

	
	
</head>
<body>
<canvas id="renderCanvas"></canvas>
</body>

<script>



document.addEventListener("DOMContentLoaded", () => {
var canvas = document.getElementById('renderCanvas');			
var engine = new BABYLON.Engine(canvas, true);

var createScene = function () {
    var scene = new BABYLON.Scene(engine);
	var camPos = new BABYLON.Vector3(1.4480025568455166, 1.763735252760583, -1.199489465458897);
    var camera = new BABYLON.FreeCamera("camera1", camPos, scene);
    camera.setTarget(new BABYLON.Vector3(0, 0.5, 0));
    camera.attachControl(canvas, true);
    var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
    light.intensity = 0.7;
    
	camera.speed = 0.5;
	camera.minZ = 0.0001;
	
	
	
	var shader = new BABYLON.ShaderMaterial("tpShader", scene, {
					vertex: "tpMain",
					fragment: "tpMain",
					},{
					attributes: ["position", "normal", "uv", "color"],
					defines: [],
					samplers: ['texture0'],
					uniforms: ["world",
					"worldView", 
					"worldViewProjection",
					"view", "rChannel", "gChannel", "bChannel"]
	});
				
	var texture0 = new BABYLON.Texture('./wood_preview.jpeg', scene, false, false, 1, (e)=>{
		shader.setTexture("texture0", texture0);
		console.log(texture0);
		shader.setVector2("textureSize", new BABYLON.Vector2(texture0._texture.baseWidth, texture0._texture.baseHeight));
		shader.setVector3("rChannel", new BABYLON.Vector3(1.0,0.5,1.0));
		shader.setVector3("gChannel", new BABYLON.Vector3(0.0,0.0,2));
		shader.setVector3("bChannel", new BABYLON.Vector3(0.0,0.0,2));		
	});	

	BABYLON.SceneLoader.Append("./", "RGB-Mapping.babylon", scene, (e)=>{
		
		for(var i=0; i<e.meshes.length; i++){
			e.meshes[i].material = shader;
			
		}
	});	
	
	
	
    return scene;
};

	scene = createScene();
		
		window.addEventListener("resize",()=>{				
			engine.resize();
		});
		
		engine.runRenderLoop(()=>{
			scene.render(); 
		});		
		
},false);




var _vs = 
`precision highp float;
// Attributes
attribute vec3 position;
attribute vec3 normal;
attribute vec2 uv;
attribute vec4 color;
// Uniforms
uniform mat4 worldViewProjection;

varying vec3 vPosition;
varying vec2 vUV;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 absNormal;


void main() {
    vec4 p = vec4( position, 1. );    
	vPosition = p.xyz;	
	gl_Position = worldViewProjection * p;	
	vUV = uv;
	vColor = color;
	vNormal = normal;
	absNormal = abs(normalize(normal));
}`;

var _fs = 
`precision highp float;

varying vec3 vPosition;
varying vec2 vUV;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 absNormal;

uniform sampler2D texture0;

uniform vec2 textureSize;

uniform vec3 rChannel;
uniform vec3 gChannel;
uniform vec3 bChannel;

void main(){	
	
	vec3 color = vec3(1.0);
	float alpha = 1.0;
	vec2 ratio = vec2(textureSize.y/textureSize.x, 1.0);	
	
	vec3 blending = absNormal;
	blending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0
	float b = (blending.x + blending.y + blending.z);
	blending /= vec3(b, b, b);	
	if(vColor.r > 0.){
		color = 
		((texture2D(texture0, (vPosition.zy+rChannel.xy)*((ratio*rChannel.z))*vec2(0.5, 0.5)).rgb)*blending.x)+
		((texture2D(texture0, (vPosition.zx+rChannel.xy)*(ratio*rChannel.z)).rgb)*blending.y)+
		((texture2D(texture0, (vPosition.yx+rChannel.xy)*(ratio*rChannel.z)).rgb)*blending.z);

	}else if(vColor.g > 0.){		
		color =
		((texture2D(texture0, (vPosition.yz+gChannel.xy)*(ratio*gChannel.z)).rgb)*blending.x)+
		((texture2D(texture0, (vPosition.xz+gChannel.xy)*(ratio*gChannel.z)).rgb)*blending.y)+
		((texture2D(texture0, (vPosition.yx+gChannel.xy)*((ratio*gChannel.z))*vec2(0.5, 0.5)).rgb)*blending.z);
		
	}else if(vColor.b > 0.){
		color = 
		((texture2D(texture0, (vPosition.zy+bChannel.xy)*(ratio*bChannel.z)).rgb)*blending.x)+
		((texture2D(texture0, (vPosition.xz+bChannel.xy)*((ratio*bChannel.z))*vec2(0.5, 0.5)).rgb)*blending.y)+
		((texture2D(texture0, (vPosition.xy+bChannel.xy)*(ratio*bChannel.z)).rgb)*blending.z);
	}

	gl_FragColor =  vec4(color, alpha);
}
`;

BABYLON.Effect.ShadersStore["tpMainVertexShader"] = _vs;
BABYLON.Effect.ShadersStore["tpMainFragmentShader"] = _fs;




</script>


</html>